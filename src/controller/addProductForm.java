package controller;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.stage.Stage;
import model.Part;
import model.Product;
import java.io.IOException;
import java.net.URL;
import java.util.*;

/**
 * Page where the user can create a new Product.
 *
 * The Add Product Page gives the user a chance to create his/her own product. The user chooses a name,
 * inventory amount, price, min, max, and determines which(if any) parts will be associated with that product.
 * The upper table on this page represents a list of all available parts to choose from. While the lower table
 * represents parts chosen to be associated with the new product. The parts in the lower table are stored as
 * an ObservableList. The product ID is auto-generated by incrementing a static variable nextProductID.
 * @see Product
 */
public class addProductForm implements Initializable {

    public TableView addProductPartsTable;           //2 tables displayed on the GUI
    public TableView addProductPartsTable2;

    public TextField addProductIDField;               //Describes the text fields on the GUI
    public TextField addProductNameField;
    public TextField addProductInvField;
    public TextField addProductPriceField;
    public TextField addProductMaxField;
    public TextField addProductMinField;
    public TextField addProductSearchField;

    public Button addProductPartsAddButton;        //Describes the buttons on the GUI
    public Button addProductRemoveButton;
    public Button addProductSaveButton;
    public Button addProductCancelButton;

    public TableColumn addProductPartID1;          //Labels for the tables' columns on the page
    public TableColumn addProductPartName1;
    public TableColumn addProductPartInv1;
    public TableColumn addProductPartPrice1;
    public TableColumn addProductPartID2;
    public TableColumn addProductPartName2;
    public TableColumn addProductPartInv2;
    public TableColumn addProductPartPrice2;

    public static int nextProductID = 1004;     //static int used to assign IDs to the products
                                                //1004 is the first ID to be assigned because 4 products
                                                //have already been created and loaded into the table
                                                //'1000', '1001', '1002', and '1003'

    public Label addProductErrorLabel;          //label to indicate the user entered data is invalid

    private ObservableList<Part> tempList = FXCollections.observableArrayList();    //a temporary list to hold parts associated with a product

    /**
     * Loads the 2 tables displayed on the page
     *
     * The initialization consists of loading the two tables on this page. The top parts table, is set
     * with a list of all available parts. The bottom parts table starts off blank, and is used to display
     * the list of associated parts with a given product.
     *
     * @param url
     * @param resourceBundle
     */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {

        addProductPartID1.setCellValueFactory(new PropertyValueFactory<>("partID"));
        addProductPartName1.setCellValueFactory(new PropertyValueFactory<>("partName"));
        addProductPartInv1.setCellValueFactory(new PropertyValueFactory<>("partInventoryLevel"));
        addProductPartPrice1.setCellValueFactory(new PropertyValueFactory<>("partPrice"));

        addProductPartID2.setCellValueFactory(new PropertyValueFactory<>("partID"));
        addProductPartName2.setCellValueFactory(new PropertyValueFactory<>("partName"));
        addProductPartInv2.setCellValueFactory(new PropertyValueFactory<>("partInventoryLevel"));
        addProductPartPrice2.setCellValueFactory(new PropertyValueFactory<>("partPrice"));

        addProductPartsTable.setItems(Part.allPartsList);
        addProductPartsTable2.setItems(tempList);

        addProductErrorLabel.setText("");
    }

    /**
     * Adds the selected part to the bottom table on the page
     *
     * The Add Product Button takes a part from the list of available parts in the upper table, and moves it
     * to the lower table, representing the list of associated parts for a given product.
     *
     * @param actionEvent Button click
     * @see Product
     */
    public void onProductAddButtonClick(ActionEvent actionEvent) {

        Part selectedPart = (Part) addProductPartsTable.getSelectionModel().getSelectedItem();
        if (selectedPart != null) {
            tempList.add(selectedPart);
        }
        addProductPartsTable2.setItems(tempList);
    }

    /**
     * Removed the selected part from the bottom table on the page
     *
     * This is the opposite of the Add Product Button. This method removes the part from the bottom table
     * and returns it back to the top, removing it from being associated with the product. Before removing,
     * the user will be prompted to confirm with an alert box.
     *
     * @param actionEvent Button click.
     */
    public void onProductRemoveButtonClick(ActionEvent actionEvent) {

        Part selectedPart = (Part) addProductPartsTable2.getSelectionModel().getSelectedItem();    //selectedPart is the user selection from the table

        if (selectedPart == null)    //if user doesn't select a part - go back
            return;

        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);  //create the confirmation box
        alert.setTitle("Associated Parts");
        alert.setHeaderText("Remove");
        alert.setContentText("Are you sure you want to remove this part?");

        Optional<ButtonType> result = alert.showAndWait();        //only delete the item if user clicks OK
        if (result.isPresent() && result.get() == ButtonType.OK) {
            tempList.remove(selectedPart);
            addProductPartsTable2.setItems(tempList);
        }
    }


    /**
     * Takes the user entered data and uses it to create a new Product
     *
     * On Save Button Click the user data will be checked to ensure the proper data types were entered
     * into their corresponding text fields. A try/catch block is used for this. If all user data is correct,
     * the inventory level will be compared with the minimum and maximum levels. Any logical errors will throw
     * an exception here as well.
     *
     * @param actionEvent - action event is the button click
     * @throws IOException - Leaving the name field blank. Entering the wrong data type. Min and Max errors
     * @see Product
     */
    public void onProductSaveButtonClick(ActionEvent actionEvent) throws IOException {
        try {
                int id = nextProductID;          //ID is auto-generated and not entered/modified by the user
                String name = addProductNameField.getText();
                if (name == "")                               //If the name field is blank an exception is thrown
                    throw new NumberFormatException();
                int inv = Integer.parseInt(addProductInvField.getText());
                double price = Double.parseDouble(addProductPriceField.getText());
                int min = Integer.parseInt(addProductMinField.getText());
                int max = Integer.parseInt(addProductMaxField.getText());
                if (min > max || inv < min || inv > max)             //inventory cannot be less than min or greater than max
                    throw new NumberFormatException();

                //if all data meets requirements, a new product is created with data from the text fields

                Product.allProductsList.add(new Product(id, name, inv, price, min, max, addProductPartsTable2.getItems()));
                nextProductID++;
                Parent root = FXMLLoader.load(getClass().getResource("/view/inventoryHome.fxml"));    //once created, the user is
                Stage myStage = (Stage) ((Node) actionEvent.getSource()).getScene().getWindow();      //returned to the main page
                Scene myScene = new Scene(root, 1200, 500);
                myStage.setTitle("Inventory Management System - Main Menu");
                myStage.setScene(myScene);
                myStage.show();

        } catch(NumberFormatException e) {
            addProductErrorLabel.setText("Fields cannot be blank. Numeric values must contain numbers." +
                    "              Min < Inv < Max");
        }
        catch(Exception e) {addProductErrorLabel.setText("An error has occurred!");}
    }


    /**
     * Cancels the add product process and returns the user back to the main page
     *
     * @param actionEvent - Button click
     * @throws IOException - An incorrect file name/location will cause an exception.
     * @see inventoryHome
     */
    public void onProductCancelButtonClick(ActionEvent actionEvent) throws IOException {

        Parent root = FXMLLoader.load(getClass().getResource("/view/inventoryHome.fxml"));
        Stage myStage = (Stage)((Node)actionEvent.getSource()).getScene().getWindow();
        Scene myScene = new Scene(root, 1200, 500);
        myStage.setTitle("Inventory Management System - Main Menu");
        myStage.setScene(myScene);
        myStage.show();
    }


    /**
     * Looks for the ID number or partial string to find a matching part.
     *
     * This is the search bar function in action. It combines the 'searchByPartName' and the
     * 'searchByPartID' methods. It first checks the string portion of the text field for potential
     * matches. If none are found, it invokes the Integer.parseInt method to try the entry as
     * a number. It checks the number against all part IDs in inventory. If no matches are found, the
     * table will display all available parts
     *
     * @param actionEvent This event is the pressing of the 'enter' button on the keyboard.
     */
    public void addProductSearch(ActionEvent actionEvent) {

        String sample = addProductSearchField.getText();
        ObservableList<Part> newList = searchByName(sample);
        if(newList.size() == 0) {
            try {
                int ID = Integer.parseInt(sample);
                if (searchByID(ID) != null)
                    newList.add(searchByID((ID)));
            }
            catch(Exception e) {
                //ignore the exception
            }
        }

        addProductPartsTable.setItems(newList);
        addProductSearchField.setText("");
    }


    /**
     * Searches the list of parts for a matching ID number. If found, returns the Part Object
     *
     * @param ID A part number input by the user.
     * @return Returns an object of type Part in the table. Will only return the object if there's an exact match.
     */
    private Part searchByID(int ID){
        ObservableList<Part> masterList = Part.getAllPartsList();
        for(int i = 0; i < masterList.size(); i++) {
            if(masterList.get(i).getPartID() == ID)
                return masterList.get(i);
        }
        return null;
    }


    /**
     * Uses a partial String entered by the user to search for a matching part
     *
     * Search by part name takes a partial string from the user as an argument.
     * The search uses the .contains method to determine if that partial string is present
     * in any of the parts in the parts list. All parts matching the criteria are returned
     * back to the user as a list, displayed in a table.
     *
     * @param partial A partial string of what the user wants to search for
     * @return Returns a list of all parts that match the user's partial string
     */
    private ObservableList<Part> searchByName(String partial) {

        ObservableList<Part> newList = FXCollections.observableArrayList();
        ObservableList<Part> masterList = Part.getAllPartsList();

        for(Part searchPart : masterList){
            if(searchPart.getPartName().toLowerCase(Locale.ROOT).contains(partial.toLowerCase(Locale.ROOT))){
                newList.add(searchPart);
            }
        }
        return newList;
    }
}
